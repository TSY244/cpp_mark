[TOC]

# 第五次任务笔记

这次任务采用分文件的方式写入，效率`upupup`



## 方法记录

1. 采取共用体公用一段内存的特性，利用位域进行切割，可以不用利用位运算符操作，值得注意的是字符也有符号，应该使用`unsigned char` 或者`unsigned int` 定义位域，否则会出现符号的情况

2. 加密原理实现：将8位字符的二进制`ascii`存储进入内存中，再用6位的方法对01序列进行读取，读取值（读取完成过后是2进制对应的10进制），再用读取值（一个十进制数），匹配对于的字典里的数

3. 解密原理实现：将带解密的编码与字典一对应（目的于，找出存入地址的01编码），利用函数，返回一个`int(也就是在字典中的下标)`,再将这个下标值以01值存入6位的共用体，再以8位的形式取出来，得到一个字符

4. 位域里面定义结构体的方式

   ```c++
   union temp
   {
       
       struct
       {
           unsigned  char zjy:2;//2指的是位(bit)
       };
       
       struct
       {
           unsigned int zjy2:8;//8指的是位
       };
       
   };
   ```

   

5. 文件操作是选择的是`fstream`,这样既可以进行文件的输入（`(ofstream是从内存到硬盘，可以实现文件的输入`）也可以实现文件输出（`ifstream是从硬盘到内存,实现的是文件的输出`），直接使用`<<`/``>>`

6. 文件操作时，判断是否打开成功

   ```c++
   if(file.fail());
   if(!file);
   if(!fin.good);
   if(fin.is_open)
   ```

7. 读取文件结束

   ```c++
   if(!file.eof());//文件结束返回真否则返回假
   ```

   

8. 用动态数组（`vector`）实现，将编码、解密成功的单个字符存入，以及输出，但是注意的是

9. `vector.size()`：计算数字的大小

10. `vector<unsigned char>::iterator p=vec.begin()`：定义迭代器，用于动态数组的遍历，将数据输出输入

11. 给`vector`填充元素时，我们需要使用，`push_back()`，依次往后面加

12. 进行编码时，需要将待编码用0将待编码补成3的倍数，便于循环；同理解码时，需要我们将待解码用“=”转变成4的倍数。

13. 编码，补零后换成等号的操作：利用计数器`count(自定义的int)`，记录加了多少次0，就有多少个`=`。

14. 解密，将'='换成‘A’的操作是，判断string类型的临时变量（用于存放待解密码）倒数第二个是否是‘=’，为真则就将最后两个换成‘0’;如果只有最后一个为‘=’则只用换一个‘0’

    ```c++
    //处理等号
    	n = tem.length();
    	if (tem[n - 2] == '=')
    	{
    		tem[n - 2] = 'A';
    		tem[n - 1] = 'A';
    	}
    	else if (tem[n - 1] == '=')
    	{
    		tem[n - 1] = 'A';
    	}
    ```

    

## 任务总结

这次任务对我来说难度还是有的，特别解密的过程对我来说不太好理解。对于这次任务自我来说用的时间没有之前多，这点是有点小进步，对于c++的运用也有了更好==